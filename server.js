const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const cors = require('cors');

// Inicializar aplica√ß√£o Express
const app = express();
const server = http.createServer(app);

// Configurar Socket.IO com CORS otimizado
const io = socketIo(server, {
  cors: {
    origin: [
      "http://localhost:19006",     // Expo local
      "https://expo.dev",           // Expo online
      "exp://192.168.*.*:19000",    // Expo LAN
      "exp://192.168.*.*:8081",     // Expo Metro
      "*"                           // Permitir todos para produ√ß√£o
    ],
    methods: ["GET", "POST", "PUT", "DELETE"],
    credentials: true,
    allowedHeaders: ["Content-Type", "Authorization"]
  },
  transports: ['websocket', 'polling'],
  pingTimeout: 60000,
  pingInterval: 25000
});

// Middleware b√°sico
app.use(cors({
  origin: '*',
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Servir arquivos est√°ticos (se houver)
app.use(express.static('public'));

// ===================== DADOS GLOBAIS DO SISTEMA =====================

let connectedUsers = {
  surdos: {},
  interpretes: {},
  empresas: {}
};

let callQueue = [];
let systemStats = {
  totalCalls: 0,
  activeCalls: 0,
  totalUsers: 0,
  uptime: new Date(),
  totalConnections: 0,
  successfulCalls: 0,
  rejectedCalls: 0
};

// ===================== ROTAS DA API REST =====================

// Rota principal - Status geral
app.get('/', (req, res) => {
  const currentTime = new Date();
  const uptimeMinutes = Math.round((currentTime - systemStats.uptime) / 1000 / 60);

  res.json({
    message: 'üöÄ Servidor Viva Libras Online!',
    status: 'Operacional',
    version: '2.0.0',
    description: 'Sistema de chamadas em tempo real para interpreta√ß√£o em Libras',
    timestamp: currentTime.toISOString(),
    stats: {
      uptime: uptimeMinutes + ' minutos',
      totalCalls: systemStats.totalCalls,
      activeCalls: callQueue.length,
      successfulCalls: systemStats.successfulCalls,
      rejectedCalls: systemStats.rejectedCalls,
      totalConnections: systemStats.totalConnections,
      connectedUsers: {
        surdos: Object.keys(connectedUsers.surdos).length,
        interpretes: Object.keys(connectedUsers.interpretes).length,
        empresas: Object.keys(connectedUsers.empresas).length,
        total: Object.keys(connectedUsers.surdos).length + 
               Object.keys(connectedUsers.interpretes).length +
               Object.keys(connectedUsers.empresas).length
      }
    },
    server: {
      platform: process.platform,
      nodeVersion: process.version,
      memoryUsage: process.memoryUsage(),
      pid: process.pid
    }
  });
});

// Status detalhado da API
app.get('/api/status', (req, res) => {
  res.json({
    status: 'online',
    timestamp: new Date().toISOString(),
    connectedUsers: {
      surdos: Object.keys(connectedUsers.surdos).length,
      interpretes: Object.keys(connectedUsers.interpretes).length,
      empresas: Object.keys(connectedUsers.empresas).length,
      total: Object.keys(connectedUsers.surdos).length + 
             Object.keys(connectedUsers.interpretes).length +
             Object.keys(connectedUsers.empresas).length
    },
    activeCalls: callQueue.length,
    totalCalls: systemStats.totalCalls,
    successfulCalls: systemStats.successfulCalls,
    rejectedCalls: systemStats.rejectedCalls,
    uptime: systemStats.uptime,
    server: 'Viva Libras Production v2.0.0',
    health: 'OK'
  });
});

// Teste de conectividade
app.get('/api/test', (req, res) => {
  res.json({
    message: '‚úÖ Servidor funcionando perfeitamente!',
    timestamp: new Date().toISOString(),
    success: true,
    latency: Date.now() - req.timestamp,
    version: '2.0.0'
  });
});

// Estat√≠sticas em tempo real
app.get('/api/stats', (req, res) => {
  res.json({
    realTimeStats: {
      ...systemStats,
      currentTime: new Date().toISOString(),
      connectedUsers: {
        surdos: Object.keys(connectedUsers.surdos).length,
        interpretes: Object.keys(connectedUsers.interpretes).length,
        empresas: Object.keys(connectedUsers.empresas).length
      },
      activeCalls: callQueue.length,
      queueDetails: callQueue.map(call => ({
        id: call.id,
        caller: call.caller?.nome || 'An√¥nimo',
        status: call.status,
        timestamp: call.timestamp
      }))
    }
  });
});

// Lista de int√©rpretes dispon√≠veis
app.get('/api/interpreters', (req, res) => {
  const availableInterpreters = Object.values(connectedUsers.interpretes)
    .filter(interpreter => interpreter.status === 'online')
    .map(interpreter => ({
      id: interpreter.id,
      nome: interpreter.nome,
      status: interpreter.status,
      lastActivity: interpreter.lastActivity
    }));

  res.json({
    available: availableInterpreters.length,
    interpreters: availableInterpreters,
    total: Object.keys(connectedUsers.interpretes).length
  });
});

// ===================== SOCKET.IO - COMUNICA√á√ÉO TEMPO REAL =====================

io.on('connection', (socket) => {
  console.log(\`üì± Nova conex√£o: \${socket.id} - \${new Date().toLocaleString('pt-BR')}\`);
  systemStats.totalConnections++;

  // Enviar status inicial para o cliente
  socket.emit('server_status', {
    message: '‚úÖ Conectado ao servidor Viva Libras',
    connectedUsers: Object.keys(connectedUsers.surdos).length + 
                   Object.keys(connectedUsers.interpretes).length +
                   Object.keys(connectedUsers.empresas).length,
    serverTime: new Date().toISOString(),
    version: '2.0.0'
  });

  // ===== REGISTRO DE USU√ÅRIOS =====
  socket.on('register_user', (data) => {
    const { type, nome, telefone, id } = data;
    console.log(\`üë§ Registrando usu√°rio: \${type} - \${nome || id}\`);

    const userData = {
      id: socket.id,
      nome: nome || \`Usu√°rio_\${Date.now()}\`,
      telefone: telefone || 'N√£o informado',
      socketId: socket.id,
      registeredAt: new Date().toISOString(),
      lastActivity: new Date().toISOString(),
      type: type
    };

    // Categorizar usu√°rio
    if (type === 'surdo' || type === 'empresa') {
      connectedUsers.surdos[socket.id] = userData;
    } else if (type === 'interprete') {
      connectedUsers.interpretes[socket.id] = {
        ...userData,
        status: 'offline',
        totalCalls: 0
      };
    }

    console.log(\`üìä Usu√°rios conectados: \${Object.keys(connectedUsers.surdos).length} surdos, \${Object.keys(connectedUsers.interpretes).length} int√©rpretes\`);

    // Broadcast estat√≠sticas atualizadas
    io.emit('stats_update', {
      connectedUsers: {
        surdos: Object.keys(connectedUsers.surdos).length,
        interpretes: Object.keys(connectedUsers.interpretes).length,
        empresas: Object.keys(connectedUsers.empresas).length
      },
      timestamp: new Date().toISOString()
    });
  });

  // ===== SOLICITA√á√ÉO DE CHAMADAS =====
  socket.on('request_call', (data) => {
    console.log('üìû Nova solicita√ß√£o de chamada:', data.caller?.nome || 'Usu√°rio an√¥nimo');
    systemStats.totalCalls++;

    // Buscar int√©rprete dispon√≠vel
    const availableInterpreters = Object.values(connectedUsers.interpretes)
      .filter(interpreter => interpreter.status === 'online');

    if (availableInterpreters.length > 0) {
      // Selecionar int√©rprete com menos chamadas (balanceamento)
      const selectedInterpreter = availableInterpreters.reduce((prev, current) => 
        (prev.totalCalls || 0) <= (current.totalCalls || 0) ? prev : current
      );

      const callData = {
        id: \`call_\${Date.now()}\`,
        caller: {
          ...data.caller,
          socketId: socket.id
        },
        interpreter: selectedInterpreter,
        timestamp: new Date().toISOString(),
        status: 'pending',
        timeout: Date.now() + 30000 // 30 segundos
      };

      console.log(\`üîÑ Enviando chamada para int√©rprete: \${selectedInterpreter.nome}\`);

      // Enviar chamada para o int√©rprete selecionado
      io.to(selectedInterpreter.socketId).emit('incoming_call', callData);

      // Adicionar √† fila de chamadas
      callQueue.push({
        ...callData,
        callerSocketId: socket.id,
        interpreterSocketId: selectedInterpreter.socketId
      });

      systemStats.activeCalls++;

      // Timeout autom√°tico para chamadas n√£o atendidas
      setTimeout(() => {
        const existingCall = callQueue.find(c => c.id === callData.id);
        if (existingCall && existingCall.status === 'pending') {
          console.log(\`‚è∞ Timeout da chamada: \${callData.id}\`);

          // Notificar timeout
          io.to(socket.id).emit('call_timeout', {
            message: 'O int√©rprete n√£o respondeu a tempo. Tente novamente.',
            callId: callData.id
          });

          // Remover da fila
          removeCallFromQueue(callData.id);
        }
      }, 30000);

    } else {
      console.log('‚ùå Nenhum int√©rprete dispon√≠vel');

      socket.emit('no_interpreter_available', {
        message: 'Nenhum int√©rprete dispon√≠vel no momento. Tente novamente em alguns instantes.',
        availableInterpreters: 0,
        totalInterpreters: Object.keys(connectedUsers.interpretes).length,
        onlineInterpreters: availableInterpreters.length,
        timestamp: new Date().toISOString()
      });
    }
  });

  // ===== ACEITAR CHAMADAS =====
  socket.on('accept_call', (data) => {
    console.log(\`‚úÖ Chamada aceita: \${data.callId}\`);
    const callIndex = callQueue.findIndex(c => c.id === data.callId);

    if (callIndex !== -1) {
      const call = callQueue[callIndex];
      call.status = 'accepted';
      call.acceptedAt = new Date().toISOString();

      // Atualizar estat√≠sticas do int√©rprete
      if (connectedUsers.interpretes[socket.id]) {
        connectedUsers.interpretes[socket.id].totalCalls = 
          (connectedUsers.interpretes[socket.id].totalCalls || 0) + 1;
      }

      // Notificar surdo da conex√£o bem-sucedida
      io.to(call.callerSocketId).emit('call_accepted', {
        interpreter: data.interpreter || call.interpreter,
        callId: data.callId,
        message: '‚úÖ Conectado com int√©rprete! Iniciando videochamada...',
        timestamp: new Date().toISOString()
      });

      systemStats.successfulCalls++;
      console.log(\`üéâ Chamada \${data.callId} conectada com sucesso!\`);
    }
  });

  // ===== REJEITAR CHAMADAS =====
  socket.on('reject_call', (data) => {
    console.log(\`‚ùå Chamada rejeitada: \${data.callId}\`);
    const call = callQueue.find(c => c.id === data.callId);

    if (call) {
      // Notificar surdo da rejei√ß√£o
      io.to(call.callerSocketId).emit('call_rejected', {
        message: 'Int√©rprete n√£o est√° dispon√≠vel. Procurando outro...',
        callId: data.callId,
        timestamp: new Date().toISOString()
      });

      systemStats.rejectedCalls++;
      removeCallFromQueue(data.callId);
    }
  });

  // ===== ATUALIZAR STATUS DO INT√âRPRETE =====
  socket.on('update_status', (data) => {
    if (connectedUsers.interpretes[socket.id]) {
      const oldStatus = connectedUsers.interpretes[socket.id].status;
      connectedUsers.interpretes[socket.id].status = data.status;
      connectedUsers.interpretes[socket.id].lastActivity = new Date().toISOString();

      console.log(\`üîÑ Status do int√©rprete \${socket.id} atualizado: \${oldStatus} ‚Üí \${data.status}\`);

      // Broadcast mudan√ßa de status
      io.emit('interpreter_status_update', {
        interpreterId: socket.id,
        status: data.status,
        availableInterpreters: Object.values(connectedUsers.interpretes)
          .filter(i => i.status === 'online').length,
        timestamp: new Date().toISOString()
      });
    }
  });

  // ===== FINALIZAR CHAMADAS =====
  socket.on('end_call', (data) => {
    console.log(\`üîö Finalizando chamada do usu√°rio: \${socket.id}\`);
    const callIndex = callQueue.findIndex(call => 
      call.callerSocketId === socket.id || call.interpreterSocketId === socket.id
    );

    if (callIndex !== -1) {
      const call = callQueue[callIndex];

      // Notificar ambas as partes
      io.to(call.callerSocketId).emit('call_ended', {
        message: 'Chamada finalizada. Obrigado por usar o Viva Libras!',
        duration: Date.now() - new Date(call.timestamp).getTime(),
        timestamp: new Date().toISOString()
      });

      io.to(call.interpreterSocketId).emit('call_ended', {
        message: 'Atendimento finalizado com sucesso.',
        timestamp: new Date().toISOString()
      });

      removeCallFromQueue(call.id);
    }
  });

  // ===== DESCONEX√ÉO =====
  socket.on('disconnect', (reason) => {
    console.log(\`üì¥ Usu√°rio desconectado: \${socket.id} - Motivo: \${reason} - \${new Date().toLocaleString('pt-BR')}\`);

    // Limpar usu√°rio das listas
    const wasInterpreter = !!connectedUsers.interpretes[socket.id];
    delete connectedUsers.surdos[socket.id];
    delete connectedUsers.interpretes[socket.id];
    delete connectedUsers.empresas[socket.id];

    // Finalizar chamadas ativas do usu√°rio
    const activeCall = callQueue.find(call => 
      call.callerSocketId === socket.id || call.interpreterSocketId === socket.id
    );

    if (activeCall) {
      // Notificar a outra parte da desconex√£o
      const otherSocketId = activeCall.callerSocketId === socket.id 
        ? activeCall.interpreterSocketId 
        : activeCall.callerSocketId;

      io.to(otherSocketId).emit('call_ended', {
        message: 'A outra pessoa desconectou. Chamada finalizada.',
        reason: 'disconnect',
        timestamp: new Date().toISOString()
      });

      removeCallFromQueue(activeCall.id);
    }

    // Broadcast estat√≠sticas atualizadas
    io.emit('stats_update', {
      connectedUsers: {
        surdos: Object.keys(connectedUsers.surdos).length,
        interpretes: Object.keys(connectedUsers.interpretes).length,
        empresas: Object.keys(connectedUsers.empresas).length
      },
      interpreterDisconnected: wasInterpreter,
      timestamp: new Date().toISOString()
    });
  });

  // ===== HEARTBEAT/PING =====
  socket.on('ping', (data) => {
    socket.emit('pong', {
      timestamp: new Date().toISOString(),
      serverTime: Date.now(),
      ...data
    });
  });
});

// ===================== FUN√á√ïES AUXILIARES =====================

// Remover chamada da fila
function removeCallFromQueue(callId) {
  const index = callQueue.findIndex(c => c.id === callId);
  if (index !== -1) {
    callQueue.splice(index, 1);
    systemStats.activeCalls = Math.max(0, systemStats.activeCalls - 1);
    console.log(\`üóëÔ∏è Chamada \${callId} removida da fila\`);
  }
}

// Limpeza autom√°tica de dados antigos
function cleanupOldData() {
  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);

  // Limpar chamadas antigas (mais de 1 hora)
  const oldCalls = callQueue.filter(call => 
    new Date(call.timestamp) < oneHourAgo
  );

  oldCalls.forEach(call => removeCallFromQueue(call.id));

  if (oldCalls.length > 0) {
    console.log(\`üßπ Limpeza autom√°tica: \${oldCalls.length} chamadas antigas removidas\`);
  }

  // Limpar usu√°rios inativos (mais de 2 horas)
  const twoHoursAgo = new Date(Date.now() - 2 * 60 * 60 * 1000);

  Object.keys(connectedUsers.interpretes).forEach(socketId => {
    const interpreter = connectedUsers.interpretes[socketId];
    if (interpreter.lastActivity && new Date(interpreter.lastActivity) < twoHoursAgo) {
      delete connectedUsers.interpretes[socketId];
      console.log(\`üßπ Int√©rprete inativo removido: \${interpreter.nome}\`);
    }
  });
}

// Log de estat√≠sticas peri√≥dico
function logStats() {
  const connectedCount = Object.keys(connectedUsers.surdos).length + 
                        Object.keys(connectedUsers.interpretes).length +
                        Object.keys(connectedUsers.empresas).length;

  console.log('üìä ===== ESTAT√çSTICAS DO SERVIDOR =====');
  console.log(\`   üë• Usu√°rios conectados: \${connectedCount}\`);
  console.log(\`   üìû Chamadas ativas: \${callQueue.length}\`);
  console.log(\`   üìà Total de chamadas: \${systemStats.totalCalls}\`);
  console.log(\`   ‚úÖ Chamadas bem-sucedidas: \${systemStats.successfulCalls}\`);
  console.log(\`   ‚ùå Chamadas rejeitadas: \${systemStats.rejectedCalls}\`);
  console.log(\`   üîÑ Total de conex√µes: \${systemStats.totalConnections}\`);
  console.log(\`   üïê Uptime: \${Math.round((new Date() - systemStats.uptime) / 1000 / 60)} minutos\`);
  console.log(\`   üíæ Mem√≥ria: \${Math.round(process.memoryUsage().heapUsed / 1024 / 1024)} MB\`);
  console.log('üìä ====================================');
}

// ===================== AGENDAMENTOS E LIMPEZAS =====================

// Limpeza autom√°tica a cada 1 hora
setInterval(cleanupOldData, 60 * 60 * 1000);

// Log de estat√≠sticas a cada 15 minutos
setInterval(logStats, 15 * 60 * 1000);

// Health check a cada 5 minutos
setInterval(() => {
  console.log(\`üíì Health check - \${new Date().toLocaleString('pt-BR')} - Sistema OK\`);
}, 5 * 60 * 1000);

// ===================== INICIALIZA√á√ÉO DO SERVIDOR =====================

const PORT = process.env.PORT || 3001;
server.listen(PORT, () => {
  console.log('üöÄ ==========================================');
  console.log(\`üì° Servidor Viva Libras Online na porta \${PORT}\`);
  console.log('üìû Sistema de chamadas em tempo real ativo');
  console.log('üåê Pronto para receber conex√µes globais!');
  console.log(\`üïê Iniciado em: \${new Date().toLocaleString('pt-BR')}\`);
  console.log(\`üèóÔ∏è Ambiente: \${process.env.NODE_ENV || 'development'}\`);
  console.log(\`üîß Node.js: \${process.version}\`);
  console.log('üöÄ ==========================================');
});

// ===================== TRATAMENTO DE ERROS =====================

process.on('uncaughtException', (error) => {
  console.error('‚ùå Erro n√£o capturado:', error);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('‚ùå Promise rejeitada:', reason);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('üì¥ Recebido SIGTERM, encerrando servidor...');
  server.close(() => {
    console.log('‚úÖ Servidor encerrado com sucesso');
    process.exit(0);
  });
});

process.on('SIGINT', () => {
  console.log('üì¥ Recebido SIGINT, encerrando servidor...');
  server.close(() => {
    console.log('‚úÖ Servidor encerrado com sucesso');
    process.exit(0);
  });
});